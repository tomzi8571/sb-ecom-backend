# Keep-alive configuration anchors moved into top-level `env` so the workflow schema accepts them.
env:
  CRON_EXPR: &CRON_EXPR '*/20 * * * *'    # change this cron expression to update schedule
  KEEP_ALIVE_MINUTES: &KEEP_ALIVE_MINUTES 20  # total minutes to run the keep-alive loop

name: Render Keep-Alive (ping + optional redeploy)

# Keeps a Render service awake by periodically pinging the public URL or
# triggering the Render redeploy hook. Adjust the cron frequency to suit your needs.

on:
  schedule:
    - cron: *CRON_EXPR # every 20 minutes — change CRON_EXPR above as needed
  workflow_dispatch: {}

jobs:
  keep-alive:
    # Use `ubuntu-latest` for GitHub-hosted runners. If you prefer a self-hosted runner
    # change this to: runs-on: [self-hosted, linux, keepalive]
    runs-on: ubuntu-latest

    # Job-level environment: KEEP_ALIVE_MINUTES is set from the YAML anchor above.
    # PING_INTERVAL_SECONDS controls how often each ping runs (default 60 = 1 minute).
    env:
      KEEP_ALIVE_MINUTES: *KEEP_ALIVE_MINUTES
      PING_INTERVAL_SECONDS: 60

    steps:
      - name: Run keep-alive loop (KEEP_ALIVE_MINUTES pings, 1 per PING_INTERVAL_SECONDS)
        env:
          SERVICE_WEB_URL: ${{ secrets.SERVICE_WEB_URL }}
        run: |
          # exit on unset vars and non-zero commands; pipefail helps catch failures
          set -euo pipefail

          if [ -z "${SERVICE_WEB_URL:-}" ]; then
            echo "Missing secret SERVICE_WEB_URL. Create it at Settings → Secrets and variables → Actions.";
            exit 1;
          fi

          # Build the full URL and ensure we don't have a trailing slash duplication
          KEEP_ALIVE_URL="${SERVICE_WEB_URL%/}/api/public/products"

          echo "Starting keep-alive to ${KEEP_ALIVE_URL} (for ${KEEP_ALIVE_MINUTES} minutes, interval ${PING_INTERVAL_SECONDS}s)"

          # Validate numeric inputs
          if ! echo "${KEEP_ALIVE_MINUTES}" | grep -Eq '^[0-9]+$'; then
            echo "KEEP_ALIVE_MINUTES must be a positive integer. Current value: ${KEEP_ALIVE_MINUTES}"; exit 2;
          fi
          if ! echo "${PING_INTERVAL_SECONDS}" | grep -Eq '^[0-9]+$'; then
            echo "PING_INTERVAL_SECONDS must be a positive integer. Current value: ${PING_INTERVAL_SECONDS}"; exit 2;
          fi

          # Calculate number of pings = total minutes * (60 / interval_seconds)
          PINGS=$(( (KEEP_ALIVE_MINUTES * 60) / PING_INTERVAL_SECONDS ))
          if [ "$PINGS" -lt 1 ]; then
            echo "Computed PINGS < 1 (KEEP_ALIVE_MINUTES=${KEEP_ALIVE_MINUTES}, PING_INTERVAL_SECONDS=${PING_INTERVAL_SECONDS}). Nothing to do."; exit 0;
          fi

          echo "Will perform ${PINGS} ping(s) using interval ${PING_INTERVAL_SECONDS}s"

          FAILURES=0
          for i in $(seq 1 $PINGS); do
            echo "$(date -u +"%Y-%m-%dT%H:%M:%SZ") Ping #$i"

            # Save response body to a temp file, capture HTTP status code.
            TMP_BODY="$(mktemp)"
            # Use -sS to show errors on stderr but keep stdout for -w.
            HTTP_CODE=$(curl -sS -o "$TMP_BODY" -w "%{http_code}" --max-time 15 "$KEEP_ALIVE_URL") || true

            if [ -z "${HTTP_CODE:-}" ]; then
              echo "curl did not return an HTTP code (curl failed).";
              FAILURES=$((FAILURES+1));
            else
              echo "HTTP status: ${HTTP_CODE}"

              echo "Response body (trimmed to 2000 bytes):"
              head -c 2000 "$TMP_BODY" || true
              echo "\n--- end response (truncated) ---"

              case "$HTTP_CODE" in
                2*) echo "Ping #$i succeeded" ;;
                *) echo "Ping #$i returned non-2xx"; FAILURES=$((FAILURES+1)) ;;
              esac
            fi

            rm -f "$TMP_BODY" || true

            # Sleep only between pings, not after the last one
            if [ "$i" -lt "$PINGS" ]; then
              sleep "$PING_INTERVAL_SECONDS"
            fi
          done

          if [ "$FAILURES" -gt 0 ]; then
            echo "${FAILURES} ping(s) failed"; exit 1;
          fi

          echo "All pings succeeded"

#      - name: Optional: Trigger Render redeploy hook
#        if: ${{ secrets.RENDER_DEPLOY_HOOK_URL }}
#        env:
#          RENDER_DEPLOY_HOOK_URL: ${{ secrets.RENDER_DEPLOY_HOOK_URL }}
#        run: |
#          if [ -z "$RENDER_DEPLOY_HOOK_URL" ]; then
#            echo "RENDER_DEPLOY_HOOK_URL secret not set; skipping redeploy.";
#            exit 0;
#          fi
#
#          echo "Calling Render redeploy hook"
#          curl -sSf "$RENDER_DEPLOY_HOOK_URL" || { echo "Redeploy webhook call failed"; exit 1; }

# Notes:
# - Create the repository secrets used above at: Settings → Secrets and variables → Actions
#   * SERVICE_WEB_URL: the public URL of the Render service (https://your-service.onrender.com or custom domain)
# - If you want the job to run on a self-hosted runner, register a runner in your repository or organization,
#   add a label such as `keepalive`, and set `runs-on: [self-hosted, linux, keepalive]`.
# - The cron expression is defined at the top under CRON_EXPR (YAML anchor). Because GitHub Actions does
#   not expand runtime environment variables inside the `on.schedule.cron`, we cannot interpolate the
#   numeric minutes into the cron expression. Change CRON_EXPR and KEEP_ALIVE_MINUTES_ANCHOR at the top
#   to modify the schedule and loop duration.
